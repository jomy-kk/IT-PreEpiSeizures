# -*- encoding: utf-8 -*-

# ===================================

# IT - LongTermBiosignals

# Package: biosignals
# Module: Timeseries
# Description: Class Timeseries, which mathematically conceptualizes timeseries and their behaviour.
# Class OverlappingTimeseries, a special kind of Timeseries for signal processing purposes.

# Contributors: JoÃ£o Saraiva, Mariana Abreu
# Created: 20/04/2022
# Last Updated: 22/07/2022

# ===================================

from datetime import datetime, timedelta
from typing import Tuple, Sequence

from datetimerange import DateTimeRange
from multimethod import multimethod
from multipledispatch import dispatch
from numpy import ndarray
from pandas import DataFrame

from ltbio._core.operations import Operation, Operator
from ltbio.biosignals import Timeline
from ltbio.biosignals._Segment import Segment
from ltbio.biosignals.units import Unit


class Timeseries():

    # INITIALIZERS
    @multimethod
    def __init__(self, segments_by_time: dict[datetime, ndarray[float] | Sequence[float] | Segment], sampling_frequency: float,
                 units: Unit = None, name: str = None): ...

    # GETTERS
    @property
    def segments(self) -> tuple[Segment]: ...

    @property
    def n_segments(self) -> int: ...
    @property
    def sampling_frequency(self) -> float: ...
    @property
    def start(self) -> datetime: ...
    @property
    def end(self) -> datetime: ...
    @property
    def duration(self) -> timedelta: ...
    @property
    def domain(self) -> Timeline: ...
    @property
    def unit(self) -> Unit: ...
    @property
    def name(self) -> str: ...

    # SETTERS
    @name.setter
    def name(self, name: str) -> None: ...

    # BOOLEAN CHECKERS
    @property
    def is_contiguous(self) -> bool: ...

    # BUILT-INS (Basics)
    def __copy__(self) -> Timeseries: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> iter: ...
    @multimethod
    def __contains__(self, item: datetime | DateTimeRange) -> bool: ...
    @multimethod
    def __contains__(self, item: str) -> bool: ...

    # BUILT-INS (Indexing)
    @multimethod
    def __getitem__(self, item: int) -> Segment: ...
    @multimethod
    def __getitem__(self, item: datetime) -> float: ...
    @multimethod
    def __getitem__(self, item: str) -> float | Timeseries: ...
    @multimethod
    def __getitem__(self, item: DateTimeRange) -> float | Timeseries: ...
    @multimethod
    def __getitem__(self, item: Timeline) -> float | Timeseries: ...
    @multimethod
    def __getitem__(self, item: slice) -> float | Timeseries: ...
    @multimethod
    def __getitem__(self, item: tuple) -> float | Timeseries: ...

    # BUILT-INS (Joining Timeseries)
    @multimethod
    def concatenate(self, other: Timeseries) -> Timeseries: ...
    @multimethod
    def append(self, other: Segment) -> Timeseries: ...
    @multimethod
    def append(self, other: ndarray | Sequence[float | int]) -> Timeseries: ...
    @classmethod
    def overlap(cls, first: 'Timeseries', second: 'Timeseries') -> Tuple[DateTimeRange]: ...

    # BUILT-INS (Arithmetic)
    @multimethod
    def __add__(self, other: 'Timeseries') -> 'Timeseries': ...

    @multimethod
    def __add__(self, other: float) -> 'Timeseries': ...

    @multimethod
    def __sub__(self, other: 'Timeseries') -> 'Timeseries': ...

    @multimethod
    def __sub__(self, other: float) -> 'Timeseries': ...

    @multimethod
    def __mul__(self, other: 'Timeseries') -> 'Timeseries': ...

    @multimethod
    def __mul__(self, other: float) -> 'Timeseries': ...

    @multimethod
    def __truediv__(self, other: 'Timeseries') -> 'Timeseries': ...

    @multimethod
    def __truediv__(self, other: float) -> 'Timeseries': ...

    @multimethod
    def __floordiv__(self, other: 'Timeseries') -> 'Timeseries': ...

    @multimethod
    def __floordiv__(self, other: float) -> 'Timeseries': ...

    # SHORTCUT STATISTICS
    def max(self) -> float: ...
    def argmax(self) -> datetime: ...
    def min(self) -> float: ...
    def argmin(self) -> datetime: ...
    def mean(self) -> float: ...
    def median(self) -> float: ...
    def std(self) -> float: ...
    def var(self) -> float: ...
    def abs(self) -> 'Timeseries': ...
    def diff(self) -> 'Timeseries': ...

    # PLOTS
    def plot_spectrum(self, show: bool = True, save_to: str = None) -> None: ...
    def plot(self, show: bool = True, save_to: str = None) -> None: ...

    # PROCESSING
    def apply(self, operator: Operator, inplace: bool = True, **kwargs) -> Timeseries | None: ...
    @multimethod(Operation)
    def undo(self, operation) -> None: ...
    @multimethod(int)
    def undo(self, operation) -> None: ...

    # Processing Shortcuts
    def resample(self, frequency: float) -> None: ...
    def undo_segmentation(self, time_intervals: tuple[DateTimeRange]) -> None: ...

    # CONVERT TO OTHER DATA STRUCTURES
    def to_array(self) -> ndarray: ...
    def to_dataframe(self) -> DataFrame: ...

    # SERIALIZATION
    __SERIALVERSION: int = 2
    def __getstate__(self) -> tuple: ...
    def __setstate__(self, state: tuple) -> None: ...
