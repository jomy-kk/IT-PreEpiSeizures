from abc import ABC
from dataclasses import dataclass
from datetime import datetime
from datetime import timedelta
from typing import Callable

from datetimerange import DateTimeRange
from ltbio.processing.noises.Noise import Noise
from multimethod import multimethod
from numpy import ndarray
from pandas import DataFrame

from ltbio.clinical import BodyLocation, Patient
from units import Unit
from . import BiosignalSource as BS
from . import Timeline, Timeseries, Event


@dataclass
class Biosignal(ABC):

    DEFAULT_UNIT: Unit

    # INITIALIZERS
    # A. Ad-hoc
    @multimethod
    def __init__(self,
                 timeseries: dict[str | BodyLocation, Timeseries], source: BS = None, patient: Patient = None,
                 acquisition_location: BodyLocation = None, name: str = None): ...
    # B. From files
    @multimethod
    def __init__(self, path: str, source: BS = None, patient: Patient = None, acquisition_location: BodyLocation = None,
                 name: str = None): ...

    # SPECIAL INITIALIZERS
    @classmethod
    def from_template(cls) -> Biosignal: ...
    @classmethod
    def with_additive_noise(cls, original: Biosignal, noise: Noise, name: str = None) -> Biosignal: ...
    @classmethod
    def from_noise(cls, noises: Noise | dict[str | BodyLocation, Noise], time_intervals: DateTimeRange | tuple[DateTimeRange], name: str = None) -> Biosignal: ...

    # PROPERTIES (Booleans)
    @property
    def has_single_channel(self) -> bool: ...

    # PROPERTIES (Getters)
    @property
    def name(self) -> str: ...
    @property
    def n_channels(self) -> int: ...
    @property
    def channels(self) -> set(Timeseries): ...
    @property
    def channel_names(self) -> set[str | BodyLocation]: ...
    @property
    def patient(self) -> Patient: ...
    @property
    def acquisition_location(self) -> BodyLocation: ...
    @property
    def source(self) -> BS: ...
    @property
    def start(self) -> datetime: ...
    @property
    def end(self) -> datetime: ...
    @property
    def domain(self) -> Timeline: ...
    @property
    def duration(self) -> timedelta: ...
    @property
    def events(self) -> tuple[Event]: ...
    @property
    def sampling_frequency(self) -> float | dict[str, BodyLocation: float]: ...

    # PROPERTIES (Setters)
    @name.setter
    def name(self, name: str) -> None: ...
    @patient.setter
    def patient(self, patient: Patient) -> None: ...
    @acquisition_location.setter
    def acquisition_location(self, acquisition_location: BodyLocation) -> None: ...

    # GETTERS AND SETTERS FOR MEMBERS AND ASSOCIATIONS
    def __getattr__(self, name: str) -> Timeseries | Event: ...
    def get_event(self, name: str) -> Event: ...
    def set_event_name(self, current: str, new: str) -> None: ...
    def get_channel(self, name: str | BodyLocation) -> Timeseries: ...
    def set_channel_name(self, current: str | BodyLocation, new: str | BodyLocation) -> None: ...

    # EVENTS
    @multimethod
    def associate(self, *events: Event) -> None: ...
    @multimethod
    def associate(self, **events: Event) -> None: ...
    @multimethod
    def disassociate(self, *events: Event) -> None: ...
    @multimethod
    def disassociate(self, *events: str) -> None: ...
    def disassociate_all_events(self) -> None: ...

    # BUILT-INS (Basic)
    def __len__(self) -> int | dict[str | BodyLocation: int]: ...
    def __copy__(self) -> Biosignal: ...
    def __repr__(self) -> str: ...
    def __str__(self) -> str: ...
    def __iter__(self) -> iter: ...
    @multimethod
    def __contains__(self, item: str) -> bool: ...
    @multimethod
    def __contains__(self, item: datetime | DateTimeRange) -> bool: ...

    # BUILT-INS (Arithmetic Operations)
    @multimethod
    def __add__(self, value: float) -> Biosignal: ...
    @multimethod
    def __sub__(self, value: float) -> Biosignal: ...
    @multimethod
    def __mul__(self, value: float) -> Biosignal: ...
    @multimethod
    def __truediv__(self, value: float) -> Biosignal: ...
    def __neg__(self) -> Biosignal: ...
    def __invert__(self) -> Biosignal: ...

    # BUILT-INS (Joining Biosignals)
    @multimethod
    def __add__(self, other: Biosignal) -> Biosignal: ...
    @multimethod
    def __sub__(self, other: Biosignal) -> Biosignal: ...
    @multimethod
    def __mul__(self, other: Biosignal) -> Biosignal: ...
    @multimethod
    def __truediv__(self, other: Biosignal) -> Biosignal: ...
    def __and__(self, other: Biosignal) -> Biosignal: ...
    def __rshift__(self, other: Biosignal) -> Biosignal: ...

    # BUILT-INS (Logic using Time and Amplitude values)
    @multimethod
    def __lt__(self, other: Biosignal | datetime | DateTimeRange | Timeline | Event) -> bool: ...
    @multimethod
    def __lt__(self, value: float | int) -> Timeline: ...
    @multimethod
    def __le__(self, other: Biosignal | datetime | DateTimeRange | Timeline | Event) -> bool: ...
    @multimethod
    def __le__(self, value: float | int) -> Timeline:  ...
    @multimethod
    def __gt__(self, other: Biosignal | datetime | DateTimeRange | Timeline | Event) -> bool: ...
    @multimethod
    def __gt__(self, value: float | int) -> Timeline:  ...
    @multimethod
    def __ge__(self, other: Biosignal | datetime | DateTimeRange | Timeline | Event) -> bool: ...
    @multimethod
    def __ge__(self, value: float | int) -> Timeline: ...
    @multimethod
    def __eq__(self, other: Biosignal | datetime | DateTimeRange | Timeline | Event) -> bool: ...
    @multimethod
    def __eq__(self, value: float | int) -> Timeline: ...
    @multimethod
    def __ne__(self, other: Biosignal | datetime | DateTimeRange | Timeline | Event) -> bool:  ...
    @multimethod
    def __ne__(self, value: float | int) -> Timeline: ...

    # INDEXATION
    @multimethod  # A. Index by channel or Event
    def __getitem__(self, index: str | BodyLocation) -> Biosignal: ...
    @multimethod  # B. Index by datetime
    def __getitem__(self, index: datetime) -> Biosignal: ...
    @multimethod  # C. Index by DateTimeRange
    def __getitem__(self, index: DateTimeRange) -> Biosignal: ...
    @multimethod  # D. Index by Timeline
    def __getitem__(self, index: Timeline) -> Biosignal: ...
    @multimethod  # D. Index with a condition
    def __getitem__(self, index: callable) -> Biosignal: ...
    @multimethod  # B. Index with slice of datetimes or padded events
    def __getitem__(self, index: slice) -> Biosignal: ...
    @multimethod  # Z. Multiple of the above indices
    def __getitem__(self, index: tuple) -> Biosignal: ...

    # USEFUL TOOLS
    @property
    def preview(self) -> Biosignal: ...
    def when(self, condition: callable, window: timedelta = None) -> Timeline: ...
    def restructure_domain(self, time_intervals: tuple[DateTimeRange]) -> None: ...
    def acquisition_scores(self) -> tuple[float, float, float]: ...
    def completeness_score(self) -> float: ...
    def onbody_score(self) -> float: ...
    def quality_score(self, _onbody_duration=None) -> float: ...

    # PROCESSING
    def apply(self, operation: Callable, inplace: bool = True, **kwargs) -> Biosignal | None: ...
    @multimethod
    def undo(self, operation: Callable) -> None: ...
    @multimethod
    def undo(self, operation: int) -> None:...
    # Processing Shortcuts
    def resample(self, frequency: float) -> None: ...
    def invert(self, channel_label: str = None) -> None: ...
    def undo_segmentation(self, time_intervals: tuple[DateTimeRange]) -> None: ...

    # PLOTS
    def plot_spectrum(self, show: bool = True, save_to: str = None) -> None: ...
    def plot(self, show: bool = True, save_to: str = None) -> None: ...
    def plot_summary(self, show: bool = True, save_to: str = None) -> None: ...

    # CONVERT TO OTHER DATA STRUCTURES
    def to_dict(self) -> dict[str | BodyLocation, Timeseries]: ...
    def to_array(self) -> ndarray: ...
    def to_dataframe(self) -> DataFrame: ...

    # SERIALIZATION
    EXTENSION = '.biosignal'
    __SERIALVERSION: int = 2
    def __getstate__(self) -> tuple: ...
    def __setstate__(self, state: tuple) -> None: ...
    def save(self, filepath: str) -> None: ...
    @classmethod
    def load(cls, filepath: str) -> Biosignal: ...


class DerivedBiosignal(Biosignal):
    @classmethod
    def derived_from(cls, biosignal: Biosignal) -> DerivedBiosignal: ...


class MultimodalBiosignal(Biosignal):

    @multimethod
    def __init__(self, **biosignals: Biosignal) -> MultimodalBiosignal: ...

    # PROPERTIES
    @property
    def modalities(self) -> set[Biosignal.__subclasses__()]: ...
    @property
    def source(self) -> set[BS]: ...
    @property
    def acquisition_location(self) -> set[BodyLocation]: ...

    # BUILT-INS (Basic)
    def __repr__(self) -> str: ...
    def __str__(self) -> str: ...

    # INDEXATION
    @multimethod
    def __getitem__(self, item: Biosignal.__subclasses__()) -> Biosignal: ...

    # PLOTS
    def plot_summary(self, show: bool = True, save_to: str = None):
        raise TypeError("Functionality not available for Multimodal Biosignals.")

